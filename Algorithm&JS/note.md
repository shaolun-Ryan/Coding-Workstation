Js&Algorithm笔记
===
*****
# 什么是数据结构？
在计算机中，存储和组织数据的方式
我们要力求搞高效的组织和存储数据
# 什么是算法？
有限指令集，接受一些输入并且产生输出
在有限的步骤之后结束
**********
# 栈结构
栈是一种常见的数据结构
* 数据是一个线性结构，可以再任意位置插入和删除元素
而栈和队列就是比较常见的线性元素

## 栈结构示意图
![占位文字](../static\8.22.1.png "栈结构示意图")
* 特性
  * 要插入元素，不能直接在栈的顺序中插入，像数组一样，必须要遵循后进先出，只能在栈顶插入
  * 只能在栈的一端进行插入和删除运算，操作的一端叫做栈顶
  * LIFO（last in first out）后进先出
  * 生活中类似的：自助餐的托盘
  * 程序中的实现
    * 函数调用栈
    ![占位文字](../static\8.22.2.png "栈结构示意图")
    * 无限次的递归，就会出现栈溢出的情况
* 一个方便理解的面试题
  * ![占位文字](../static\8.22.3.png "栈结构示意图")
  * 答案：C（6不可能在5前面）

***
## 栈结构的实现
* 基于数组
* 基于链表

构建栈的代码：见 栈的封装.js

# 队列
另外一种受限的线性结构
符合先进先出的原理
在后端添加元素，在前段删除元素
![占位文字](../static\8.23.1.png "栈结构示意图")
生活场景：电影院排队进场
开发：打印队列，线程队列
* 队列的实现
  * 基于数组实现
  * 基于链表实现

## 优先级队列
在插入一个元素时会考虑数据的优先级
在进行比较后的出数据在队列中的正确位置
插入优先级比他还小的元素前面
其他处理方式，和普通队列基本一样

* 应用场景
  * 头等舱和商务舱的优先级
  * 老人和孕妇在公共车上    
  * 看病时，普通和急诊

# 链表
数组的缺点：要申请一端连续的内存空间，并且通常大小是固定的，超出时一般需要扩容
在数组开头或者中间插入数据时，要进行大量的元素的位移

* 链表的优势
  * 链表在内存中不必是连续的空间
  * 链表的每一个元素由元素本身的节点和指向下一个元素的引用（优势成为指针或者连接）组成
  * 方便实现动态管理（due to 1）
  * 链表不必在创建时就确定大小，可以无限延伸下去
  * 链表在插入和删除数据时，时间复杂度可以达到O(1)，效率非常高
* 链表的缺点
  * 链表访问一个元素时，都需要从头开始访问
  * 无法通过下标直接访问元素，需要从头一个一个访问，直接找到对应的元素
* 链表的结构，十分像一个火车


# 双向链表
链表相连的过程是双向的
一个节点既有向后的指针，也有向前的指针

* 缺点
  * 在==插入和删除==某个节点时，需要处理四个引用
  * 内存空间更大一些
  * 但这些和方便程度相比，是微不足道的
  
![占位文字](..\static\8.27.1.png "栈结构示意图")

# 集合
比较常见的结构是==哈希表==
集合是由一组==无序的，不能重复==的元素构成
和数学中学的集合挺相似

ES6中已经有了集合类

## 集合之间的操作
并集
交集
差集
子集

*笔记：js中return、return false和return true的区别：return 是函数的出口指令，遇到return就直接跳出循环或者函数，所以在一个包含多个return的函数中，遇到第一个return即可结束函数*

## 字典
主要特点：==一一对应==的关系
使用字典的方式{‘age’:18,"name":"Ryan",'height':1.88}
通过键值对，通过keys来取出value
字典中的key是不可重复的，而value可以重复，字典中的key是无序的

# 哈希表
基于==数组==实现的
回顾一下数组：数组的插入效率很低（需要将所有元素的位置每一个都移动）
查找的效率高，因为是基于下标的查找。
删除的效率也不高，因为是插入方法的逆过程

* 现对于数据，哈希表有很多优势
  * 无论多少个数据，插入和删除只需要接近常量的时间：O(1)
  * 哈希表的速度比树还要快
  * 哈希表相对于树的编码要容易很多
* 不足：
  * 哈希表是没有顺序的，所以不能以一种固定的方式来遍历其中的元素
* 哈希表到底是什么呢？
  * 结构其实不清晰
  * 他的结构就是数组，但是==不是在于对下标值的一种变换==，这种变换可以称之为哈希函数，通过哈希函数来获取到HashCode
  

![占位文字](..\static\8.27.2.png "栈结构示意图")
（绿色框表示数组，红色框表示对象）
可见，通过名称来查找号码是比较慢的，因为在数组中，你需要一个一个比较对象的名称来确定是不是我们要找的那个对象，然后才可以输出号码。除非有一种方法，把名称对应到下标值，这样只需查表，就可以根据下标值直接对应到元素，比较快速。

### 字母转成数字（下标值）

>ASCII和GBK编码形式都有局限性，在生产过程中也不兼容
所以出现了Unicode，集百家之长于一身，很方便
最常用的UTF-8就是Unicode的一种

对编码方式的探究
有很多的算法

#### 认识哈希化
需要一种==压缩方法==，把幂的连乘方法得到的巨大的==整数范围==压缩到==可接受的范围==中

* 开始认识概念：
  * 哈希化：将==大数字==转化成==数组范围内下标==的过程
  * 哈希函数:通常会将==单词==转成==大数字==，==大数字==在进行==哈希化==的代码就是所谓的哈希函数
  * 哈希表：将数据和数字插入到一个==数组==完成封装，就叫做一个哈希表

#### 冲突
* 解决冲突常见的两种方案
  * 链地址法
  * 开放地址法
  
* 链地址法
  * ![占位文字](..\static\8.27.3.png "栈结构示意图")
给每一个下标值的位置，存储一个链表或数组instead of一个元素

* 开放地址法
  * 工作方式是寻找空白的单元格来添加重复的数据
  * 算法
    * 线性探测
      * ![占位文字](..\static\8.27.4.png "栈结构示意图")
      * ![占位文字](..\static\8.27.5.png "栈结构示意图")
    * 二次探测
      * 解决聚集的问题
      * 通过对步长进行了优化
      * 可以一次性探测比较长的距离，避免聚集带来的影响
      * ![占位文字](..\static\8.27.6.png "栈结构示意图")
    * 再哈希法        
      * 步长变化的探测
      * ![占位文字](..\static\8.27.7.png "栈结构示意图")

### 哈希化的效率
#### 什么是装填因子
公式：总数据项/哈希表长度

#### 设计哈希函数
* 快速的计算
* 均匀的分布
  * 无论是链地址法还是开放地址法，当多个元素映射到同一个位置的时候，都会影响效率
  
实现过程：
* 多项式的优化：霍纳法则 = 秦九韶算法
* 均匀分布：
  * 在使用常量的地方，尽量使用质数
    * 哈希表的长度
    * N次幂的底数
  
# 树结构
* 树结构的优点
  * 树结构和数组、链表和哈希表的优点
  * 我们目前最强的数据结构哈希表，也有一些缺点，比如：
    * 空间利用率不高，数据内有空余位置
    * 哈希表无序的，不能按照固定的顺序遍历哈希表
    * 不能快速找出哈希表中的最大值和最小值
  * 树结构的优势
    * 综合了以上所有数据结构的优点，但不能随意覆盖，比如效率没有哈希表高
    * 可以表示一对多的关系，比如文件的目录结构
  
## 树结构的术语
* 树：n个节点构成的有限集合
* 对任一个非空树，有以下性质：
  * 树中有一个成为“根”的特殊节点，用root表示
  * 根下有很多集合，称为“子树”
  * ![占位文字](..\static\8.28.1.png "栈结构示意图")

## 树结构的表示
普通表示方法，有几个儿子节点不确定，在封装时不确定有几个子节点
正解：用儿子-兄弟表示法
即可表示为一颗二叉树
如图：![占位文字](..\static\8.28.2.png "栈结构示意图")

* 二叉树的概念
  * 每个节点最多有两个子节点
* 二叉树的性质
  * 第i层的最大节点数为：2^i-1^
  * 深度为k的二叉树，最大节点总数为：2^k-1^
  * 叶子结点 = 度为2的非叶子结点 + 1

* 满二叉树
  * 除了最低一层的叶子结点，每层节点都有两个叶子结点，就构成了满二叉树
* 完全二叉树
  * ![占位文字](..\static\8.28.3.png "栈结构示意图")

* 二叉树的存储
  * 普通二叉树用链表表示
  * 数组只能用来表示完全二叉树

## 二叉搜索树(BST-Binary Search Tree)
如果不为空，满足以下性质：
* 非空左子树的所有键值小于根节点的键值
* 非空右子树的所有键值大于其根节点的键值
* 左右子树本身也都是二叉搜索树
* ![占位文字](..\static\8.28.4.png "栈结构示意图")

优势：搜索效率非常高，相当于一个二分查找法


